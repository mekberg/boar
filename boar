#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2010 Mats Ekberg
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from __future__ import with_statement
import sys
import os
import time
import cProfile
from optparse import OptionParser, SUPPRESS_HELP
from blobrepo import repository
from blobrepo.sessions import bloblist_fingerprint
from boar_exceptions import *
import client
import front

if sys.version_info >= (2, 6):
    import json
else:
    import simplejson as json

from front import Front, RevisionFront, set_file_contents
import workdir
from common import *
from boar_common import *

BOAR_VERSION = "<UNDEFINED>"

def print_help():
    print """Boar version %s
Usage: boar <command> 

Commands:
ci        Commit changes in a work directory
clone     Create or update a clone of a repository
co        Check out files from the repository
diffrepo  Check if two repositories are identical
getprop   Get session properties, such as file ignore lists
info      Show some information about the current workdir
import    Import the contents of a folder into your repository
list      Show the contents of a repository or snapshot
locate    Check if some non-versioned files are already present in a repository
log       Show changes and log messages
ls        Show the contents of a specific sub directory of a snapshot
mkrepo    Create a new repository
mksession Create a new session
setprop   Set session properties, such as file ignore lists
status    List any changes in the current work directory
update    Update the current work directory from the repository
verify    Verify the integrity of the repository

For most commands, you can type "boar <command> --help" to get more
information. The full command reference is available online at
http://code.google.com/p/boar/wiki/CommandReference
"""  % BOAR_VERSION

not_a_workdir_msg = "This directory is not a boar workdir"

def list_sessions(front, show_meta = False, verbose = False):
    sessions_count = {}
    for sid in front.get_session_ids():
        session_info = front.get_session_info(sid)
        name = session_info.get("name", "<no name>")
        if not show_meta and name.startswith("__"):
            continue
        sessions_count[name] = sessions_count.get(name, 0) + 1
    for name in sessions_count:
        print name, "(" + str(sessions_count[name]) + " revs)"

def list_revisions(front, session_name):
    sids = front.get_session_ids(session_name)
    if not sids:
        raise UserError("There is no such session: %s" % session_name)
    for sid in sids:
        session_info = front.get_session_info(sid)
        log_message = session_info.get("log_message", "<not specified>")
        bloblist = front.get_session_bloblist(sid)
        if front.get_base_id(sid):
            is_base = "(delta)"
        else:
            is_base = "(standalone)"
        print "Revision id", str(sid), "(" + session_info['date'] + "),", \
            len(bloblist), "files,", is_base, "Log: %s" % (log_message)

def dump_all_revisions(front):
    sids = front.get_session_ids()
    deleted_sids = front.get_deleted_snapshots()
    for sid in sids:
        session_info = front.get_session_info(sid)
        log_message = session_info.get("log_message", None)
        name = session_info.get("name", None)
        base = front.get_base_id(sid)
        deleted = sid in deleted_sids
        print json.dumps((sid, base, name, front.get_session_fingerprint(sid), log_message, deleted))
        #print json.dumps({"snapshot":sid, "base":base, "fingerprint":front.get_session_fingerprint(sid), "log":log_message, "deleted": sid in deleted_sids})

def list_files(front, session_name, revision):
    try:
        revision = int(revision)
    except:
        raise UserError("Illegal revision string: '%s'" % revision)
    session_info = front.get_session_info(revision)
    if session_info == None or session_info.get("name") != session_name:
        raise UserError("There is no such session/revision")
    for info in front.get_session_bloblist(revision):
        print info['filename'], str(info['size']/1024+1) + "k"

def verify_repo(front, verify_blobs = True):
    """Returns True if the repo was clean. Otherwise throws an
    exception."""
    for rev in range(1, front.repo_get_highest_used_revision() + 1):
        front.repo_verify_snapshot(rev)
    session_ids = front.get_session_ids()
    print "Verifying %s snapshots" % (len(session_ids))
    existing_blobs = set(front.get_all_blobs())
    for i in range(0, len(session_ids)):
        id = session_ids[i]
        bloblist = front.get_session_bloblist(id)
        calc_fingerprint = bloblist_fingerprint(bloblist)
        if calc_fingerprint != front.get_session_fingerprint(id):
            raise CorruptionError("Fingerprint didn't match for snapshot %s" % id)
        for bi in bloblist:
            if bi['md5sum'] not in existing_blobs:
                raise CorruptionError("Snapshot %s is missing blob %s" % (session_ids[i], bi['md5sum']))
        print "Snapshot %s (%s): All %s blobs ok" % (id, calc_fingerprint, len(bloblist))
    if not verify_blobs:
        print "Skipping blob verification"
        return True
    print "Collecting a list of all blobs..."
    count = front.init_verify_blobs()
    print "Verifying %s blobs..." % (count)
    done = 0
    while done < count:
        done += len(front.verify_some_blobs())
        print done, "of "+str(count)+" blobs verified, "+ \
            str(round(1.0*done/count * 100,1)) + "% done."
    return True


def cmd_locate(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar locate <session name> [[file/dir] [file/dir] ...]")
    (options, args) = parser.parse_args(args)
    if len(args) == 0:
        raise UserError("You must specify which session to look in.")
    sessionName = args[0]
    files_to_look_for = args[1:]
    if not files_to_look_for:
        files_to_look_for = ["."]
    files_to_look_for = [tounicode(os.path.abspath(fn)) for fn in files_to_look_for] 
    front = connect_to_repo(get_repo_url())    
    revision = front.find_last_revision(sessionName)
    if not revision:
        raise UserError("No such session: %s" % sessionName)
    revision_front = RevisionFront(front, revision)

    missing = []
    found = 0
    for root in files_to_look_for:
        if os.path.isdir(root):
            tree = get_tree(root, absolute_paths = True)
            tree.sort()
        else:
            tree = [root]
        for f in tree:
            csum = md5sum_file(f)
            session_filenames = list(revision_front.get_filesnames(csum))
            session_dirs = [os.path.dirname(fn) for fn in session_filenames]
            if not session_filenames:
                print "Missing:", f
                missing.append(f)
                continue
            if session_filenames:
                print "OK:", f
                found += 1
                for p in session_filenames:
                    print "   " + p
    print "%s files exists in the given session, %s do not." % (found, len(missing))
    for f in missing:
        print "Missing:", f

def cmd_status(args):
    parser = OptionParser(usage="usage: boar status [options]")
    parser.add_option("-v", "--verbose", dest = "verbose", action="store_true",
                      help="Show information about unchanged files")
    parser.add_option("-q", "--quiet", dest = "quiet", action="store_true", default=False,
                      help="Do not print any progress information")
    (options, args) = parser.parse_args(args)
    wd = workdir.init_workdir(ucwd)
    if not wd:
        raise UserError(not_a_workdir_msg)
    if args:
        raise UserError("Too many arguments")

    if wd.front.is_deleted(wd.revision):
        raise UserError("The current snapshot has been deleted in the repository.")

    wd.use_progress_printer(not options.quiet)
    unchanged_files, new_files, modified_files, deleted_files, ignored_files \
        = wd.get_changes(wd.revision)
    filestats = {}

    for f in new_files:
        filestats[f] = "A"
    for f in modified_files:
        filestats[f] = "M"
    for f in deleted_files:
        filestats[f] = "D"
    if options.verbose:
        for f in unchanged_files:
            filestats[f] = " "
        for f in ignored_files:
            filestats[f] = "i"
    filenames = filestats.keys()
    filenames.sort()
    for f in filenames:
        print filestats[f], f

def cmd_info(args):
    parser = OptionParser(usage="usage: boar info")
    (options, args) = parser.parse_args(args)
    if len(args) != 0:
        raise UserError("Info command does not accept any arguments.")

    wd = workdir.load_workdir_parameters()
    if not wd:
        raise UserError(not_a_workdir_msg)

    offset = ""
    if wd["offset"]:
        offset = "/" + wd["offset"]

    if wd:
        print "Repository:", wd["repoUrl"]
        print "Session / Path:", wd["sessionName"] + offset
        print "Snapshot id:", wd["revision"]
        print "Workdir root:", wd["root"]
        
def cmd_mkrepo(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar mkrepo <new repo path>")
    (options, args) = parser.parse_args(args)
    repository.create_repository(args[0])


def cmd_list(args):
    parser = OptionParser(usage="usage: boar list [session name [snapshot id]]")
    parser.add_option("-m", "--show-meta", dest = "show_meta", action="store_true",
                      help="Show meta sessions (stores session properties, normally hidden)")
    parser.add_option("-d", "--dump", dest = "dump", action="store_true",
                      help="Dump a machine readable listing of all revisions and their properties")
    (options, args) = parser.parse_args(args)
    if len(args) > 2:
        raise UserError("Too many arguments")
    front = connect_to_repo(get_repo_url())
    if options.dump:
        if args:
            raise UserError("a dump can not be combined with other arguments")
        dump_all_revisions(front)
    elif len(args) == 0:
        list_sessions(front, options.show_meta)
    elif len(args) == 1:
        list_revisions(front, args[0])
    elif len(args) == 2:
        list_files(front, args[0], args[1])
    else:
        raise UserError("Too many arguments")

class _ChangePrinter:
    def __init__(self, front):
        self.front = front
        self.bloblists = {}
        self.bloblists_order = []

    def get_bloblist(self, sid):
        return self.front.get_session_bloblist(sid)
        """
        # A simple cache mechanism
        if sid not in self.bloblists:
            self.bloblists[sid] = self.front.get_session_bloblist(sid)
            self.bloblists_order.append(sid)
            if len(self.bloblists_order) > 1:
                del self.bloblists[self.bloblists_order.pop(0)]
        return self.bloblists[sid]
        """

    def get_comparer(self, sid):
        front = self.front
        current_bloblist = self.get_bloblist(sid)
        base_id = front.get_base_id(sid)
        base_bloblist = self.get_bloblist(base_id) if base_id else []
        return treecompare_bloblists(base_bloblist, current_bloblist)

    def print_changes(self, sid):
        comparer = self.get_comparer(sid)
        all_filenames = list(comparer.all_changed_filenames())
        all_filenames.sort()
        print "Changed paths:"
        for filename in all_filenames:
            if comparer.is_unchanged(filename):
                continue
            elif comparer.is_new(filename):
                print "A", filename
            elif comparer.is_deleted(filename):
                print "D", filename
            elif comparer.is_modified(filename):
                print "M", filename    

    def is_affected(self, sid, path):
        comparer = self.get_comparer(sid)
        all_changed_filenames = comparer.all_changed_filenames()
        affected = path in all_changed_filenames
        if not affected:
            for affected_filename in all_changed_filenames:
                if is_child_path(path, affected_filename):
                    return True
        return affected

def _parse_range(s):
    try:
        return int(s), int(s)
    except ValueError:
        pass
    m = re.match("^(\d*):(\d*)$", s)
    if not m:
        raise UserError("Ranges must be given as N:M where N and M may be an empty string or an integer > 0")
    lower = int(m.group(1)) if m.group(1) else 1
    upper = int(m.group(2)) if m.group(2) else VERY_LARGE_NUMBER
    return lower, upper

def cmd_log(args):
    parser = OptionParser(usage="usage: boar log [-v|--verbose] [-r|--revision <rev>] [<session name>[/path]]")
    parser.add_option("-v", "--verbose", dest = "verbose", action="store_true",
                      help="List detailed change information about each revision")
    parser.add_option("-r", "--revision", action="store", dest = "revision_range",
                      help='Only show the specified revision(s). Accepts a single revision, or a range on the form "N:M"')
    (options, args) = parser.parse_args(args)
    if len(args) > 1:
        raise UserError("Too many arguments")

    session, offset = None, None

    cmdline_repo = get_repo_url_commandline()
    env_repo = get_repo_url_env()
    wd = workdir.init_workdir(ucwd)

    print >>sys.stderr, cmdline_repo, wd, env_repo
    if cmdline_repo:
        if args:
            session, offset = parse_sessionpath(args[0])
        front = connect_to_repo(cmdline_repo)
    elif wd:
        front = wd.front
        if args and (args[0].startswith("/") or args[0].startswith("\\")):
            raise UserError("Path must not be absolute")
        workdir_cwd = strip_path_offset(wd.root, ucwd)
        offset = u""
        if args:
            offset = wd.wd_sessionpath(os.path.join(workdir_cwd, args[0]))
        session = wd.sessionName
    elif env_repo:
        if args:
            session, offset = parse_sessionpath(args[0])
        front = connect_to_repo(env_repo)
    else:
        raise UserError("You must use this command in a workdir or specify a repository to operate on")

    if options.revision_range:
        range_start, range_end = _parse_range(options.revision_range)
    else:
        range_start, range_end = 1, front.get_highest_used_revision()

    anything_printed = False
    change_printer = _ChangePrinter(front)
    for sid in reversed(front.get_session_ids(session)):
        if not (range_start <= sid <= range_end):
            continue
        if offset and not change_printer.is_affected(sid, offset):
            continue
        anything_printed = True
        session_info = front.get_session_info(sid)
        log_message = session_info.get("log_message", "")
        linecount = len(log_message.splitlines())
        line_s = "lines" if linecount != 1 else "line"
        print "-" * 80
        print "r%s | %s | %s | %s log %s" % (sid, session_info['name'], 
                                             session_info.get('date', "<no date>"), linecount, line_s)
        if options.verbose:
            change_printer.print_changes(sid)
        print
        if log_message != "":
            print log_message
    if anything_printed:
        print "-" * 80

def cmd_ls(args):
    parser = OptionParser(usage="usage: boar ls <session name>[/path]")
    parser.add_option("-r", "--revision", action="store", dest = "revision", type="int", 
                      help="The revision to list (defaults to latest)")
    parser.add_option("-v", "--verbose", dest = "verbose", action="store_true",
                      help="List more information about the files.")
    (options, args) = parser.parse_args(args)
    front = connect_to_repo(get_repo_url())

    if len(args) == 0:
        list_sessions(front, show_meta = False, verbose = options.verbose)
        return
    elif len(args) > 1:
        raise UserError("Too many arguments")
    else:
        session_name, path = split_path_from_start(args[0])
        path = path.rstrip("/")

    if options.revision:
        revision = options.revision
    else:
        revision = front.find_last_revision(session_name)
        if not revision:
            raise UserError("There is no session with the name '%s'" % session_name)
    session_info = front.get_session_info(revision)
    if session_info == None or session_info.get("name") != session_name:
        raise UserError("There is no such session/revision")

    def print_info(info, path, seen_dirs):
        if path == info['filename']:
            subpath = os.path.basename(path)
        else:
            subpath = strip_path_offset(path, info['filename'])
        if "/" in subpath:
            dirname, rest = split_path_from_start(subpath)
            if dirname not in subdirs:
                print dirname + "/"
                subdirs.add(dirname)
        elif options.verbose:
            print subpath, str(info['size']/1024+1) + "kB"
        else:
            print subpath

    def info_comp(x, y):
        if x['filename'] > y['filename']:
            return 1
        if x['filename'] < y['filename']:
            return -1
        return 0

    subdirs = set()
    anything_printed = False
    bloblist = front.get_session_bloblist(revision)
    bloblist.sort(info_comp)

    for info in bloblist:
        if is_child_path(path, info['filename']) or path == info['filename']:
            print_info(info, path, subdirs)
            anything_printed = True
    if path != "" and not anything_printed:
        raise UserError("No such file or directory found in session: "+path)        
    
def cmd_verify(args):
    parser = OptionParser(usage="usage: boar verify [options]")
    parser.add_option("-q", "--quick", dest = "quick", action="store_true",
                      help="Only check that the repository looks reasonably ok (skip blob checksumming)")
    (options, args) = parser.parse_args(args)
    front = connect_to_repo(get_repo_url())
    verify_repo(front, verify_blobs = not options.quick)

def cmd_repair(args):
    parser = OptionParser(usage="usage: boar repair [options]")
    parser.add_option("-f", "--force", dest = "force", action="store_true",
                      help="Do not scan for errors before repairing")
    (options, args) = parser.parse_args(args)
    clean = False
    repo_url = get_repo_from_env()
    if repo_url.startswith("boar://"):
        raise UserError("Repairing can only be executed with a local boar repository")
    if not options.force:
        try:
            front = connect_to_repo(get_repo_url())
            print "Verifying repo before repair..."
            clean = verify_repo(front)
        except repository.SoftCorruptionError, e:
            print "Repairable error found:", e
        except Exception, e:
            print "Possible hard error found (repairing may not help):", e
    if clean:
        print "No errors found. Not repairing anything."
        return
    print "Repairing..."

def cmd_import(args):
    parser = OptionParser(usage="usage: boar import [options] <folder to import> <session name>[/path/]")
    parser.add_option("-v", "--verbose", dest = "verbose", action="store_true",
                      help=SUPPRESS_HELP)
    parser.add_option("-m", "--message", dest = "message", metavar = "ARG",
                      help="An optional log message describing this import")
    parser.add_option("-n", "--dry-run", dest = "dry_run", action="store_true", default=False,
                      help="Don't actually do anything. Just show what will happen.")
    parser.add_option("-e", "--allow-empty", dest = "allow_empty", action="store_true", default = False,
                      help="Always check in a new revision, even if there are no changes to commit.")
    parser.add_option("-w", "--create-workdir", dest = "create_workdir", action="store_true", default=False,
                      help="Turn the imported directory into a workdir.")
    parser.add_option("-q", "--quiet", dest = "quiet", action="store_true", default = False,
                      help="Do not print any progress information")
    parser.add_option("--ignore-errors", dest = "ignore_errors", action="store_true", default=False,
                      help="Continue operation even if unreadable files are detected.")
    base_session = None
    if len(args) == 0:
        args = ["--help"]
    (options, args) = parser.parse_args(args)
    if len(args) != 2:
        raise UserError("Wrong number of arguments")
    path_to_ci = tounicode(os.path.abspath(args[0]))
    import_spec = tounicode(args[1]).replace("\\", "/")
    if "/" in import_spec:
        session_name, session_offset = import_spec.split("/", 1)
        session_offset = session_offset.rstrip("/")
    else:
        session_name, session_offset = import_spec, u""
    if not os.path.exists(path_to_ci):
        raise UserError("Path to check in does not exist: " + path_to_ci)
    repourl = get_repo_url()
    front = connect_to_repo(repourl)
    if not front.find_last_revision(session_name):
        raise UserError("No session with the name '%s' exists." % (session_name))
    wd = workdir.Workdir(repourl, session_name, session_offset, None, path_to_ci)
    wd.setLogOutput(sys.stdout)
    wd.use_progress_printer(not options.quiet)
    log_message = None
    if options.message:
        log_message = tounicode(options.message)
    session_id = wd.checkin(write_meta = options.create_workdir, 
                            fail_on_modifications = True, add_only = True, dry_run = options.dry_run,
                            log_message = log_message, ignore_errors = options.ignore_errors, 
                            allow_empty = options.allow_empty)
    if session_id:
        print "Checked in session id", session_id
    else:
        notice("Nothing was imported.", sys.stdout)

def cmd_update(args):
    parser = OptionParser(usage="usage: boar update [options]")
    parser.add_option("-r", "--revision", action="store", dest = "revision", type="int", 
                      help="The revision to update to (defaults to latest)")
    parser.add_option("-i", "--ignore-errors", action="store_true", dest = "ignore_errors", 
                      help="Do not abort the update if there are errors while writing.")
    parser.add_option("-c", "--ignore-changes", action="store_true", dest = "ignore_changes", 
                      help="Update the workdir revision but do not update the workdir contents.")
    parser.add_option("-q", "--quiet", dest = "quiet", action="store_true", default = False,
                      help="Do not print any progress information")
    (options, args) = parser.parse_args(args)
    if len(args) != 0:
        raise UserError("Update does not accept any non-option arguments")
    wd = workdir.init_workdir(ucwd)
    if not wd:
        raise UserError(not_a_workdir_msg)
    wd.use_progress_printer(not options.quiet)
    new_revision = options.revision
    old_revision = wd.revision
    deleted_old_revision = wd.front.is_deleted(old_revision)
    if not new_revision:
        new_revision = wd.front.find_last_revision(wd.sessionName)
        assert not wd.front.is_deleted(new_revision) # Should not be possible, but could potentially cause deletion of workdir files
    if deleted_old_revision:
        # We can't know what has actually changed in the
        # workdir. Let's assume that any differences with latest revision
        # are modifications, to avoid overwriting any un-committed
        # workdir changes.
        old_revision = new_revision

    if options.ignore_changes:
        wd.update_revision(options.revision)
    else:
        wd.update(old_revision = old_revision, new_revision = new_revision, ignore_errors = options.ignore_errors)

    if deleted_old_revision:
        unchanged_files, new_files, modified_files, deleted_files, ignored_files = wd.last_get_changes
        if new_files or modified_files:
            warn("Because the old workdir revision was deleted, the update command was unable "+
                 "to detect changes accurately. Make sure the workdir does not contain out of "+
                 "date data before you commit.", sys.stdout) # warn to stdout to make sure it comes after "update" messages
    print "Workdir now at revision", wd.revision

def cmd_ci(args):
    parser = OptionParser(usage="usage: boar ci [options]")
    parser.add_option("-m", "--message", dest = "message", metavar = "ARG",
                      help="An optional log message describing this commit")
    parser.add_option("-a", "--add-only", dest = "addonly", action="store_true",
                      help="Only new files will be committed. Modified and deleted files will be ignored.")
    parser.add_option("-e", "--allow-empty", dest = "allow_empty", action="store_true", default = False,
                      help="Always check in a new revision, even if there are no changes to commit.")
    parser.add_option("-q", "--quiet", dest = "quiet", action="store_true", default = False,
                      help="Do not print any progress information")
    (options, args) = parser.parse_args(args)
    if args:
        raise UserError("Unexpected arguments: "+str(args))
    wd = workdir.init_workdir(ucwd)
    if not wd:
        raise UserError(not_a_workdir_msg)
    wd.use_progress_printer(not options.quiet)
    log_message = None
    if options.message:
        log_message = tounicode(options.message)    
    session_id = wd.checkin(add_only = options.addonly, log_message = log_message, allow_empty = options.allow_empty)
    if session_id:
        print "Checked in session id", session_id
    else:
        notice("Didn't find any changes to check in.", sys.stdout)

"""
def cmd_relocate(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar relocate <new repo location>")
    (options, args) = parser.parse_args(args)
    if len(args) > 1:
        raise UserError("Too many arguments")
    new_location, = args
    wd = workdir.init_workdir(ucwd)
    wd.repoUrl = new_location
    wd.write_metadata()
"""

def cmd_mksession(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar mksession <new session name>")
    (options, args) = parser.parse_args(args)
    if len(args) != 1:
        raise UserError("mksession requires a single valid session name as argument")
    session_name, = args
    front = connect_to_repo(get_repo_url())
    if front.find_last_revision(session_name) != None:
        raise UserError("There already exists a session named '%s'" % (session_name))
    front.mksession(session_name)
    print "New session '%s' was created successfully" % (session_name)

def cmd_mkstandalone(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar mkstandalone <session name>")
    (options, args) = parser.parse_args(args)
    if len(args) != 1:
        raise UserError("mkstandalone requires a single existing session name as argument")
    session_name, = args
    front = connect_to_repo(get_repo_url())
    sid = front.create_base_snapshot(session_name)
    print "New standalone snapshot %s created for session %s" % (sid, session_name)

def cmd_truncate(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar truncate <session name>")
    (options, args) = parser.parse_args(args)
    if len(args) > 1:
        raise UserError("Too many arguments")
    session_name, = args
    front = connect_to_repo(get_repo_url())
    sid = front.truncate(session_name)
    print "Session %s has been truncated to revision %s" % (session_name, sid)    

def parse_sessionpath(s):
    s = tounicode(s)
    s = s.replace("\\", "/")
    if s.startswith("/"):
        raise UserError("Session path must not start with a slash")
    session_name, throwaway, offset = s.partition("/")
    offset = offset.rstrip("/")
    assert isinstance(session_name, unicode)
    assert isinstance(offset, unicode)
    return session_name, offset

def cmd_co(args): 
    parser = OptionParser(usage="usage: boar co [options] <session name>[/path/] [workdir name]")
    parser.add_option("-r", "--revision", action="store", dest = "revision", type="int", 
                      help="The revision to check out (default is latest)")
    (options, args) = parser.parse_args(args)
    if not args:
        raise UserError("You must specify a session name with an optional subpath (i.e 'MyPictures/summer2010')")    
    if len(args) > 2:
        raise UserError("Too many arguments")
    co_spec = tounicode(args.pop(0))
    co_spec = co_spec.replace("\\", "/")
    if co_spec.startswith("/"):
        raise UserError("Checkout specification must not start with a slash")
    session_name, throwaway, offset = co_spec.partition("/")
    offset = offset.rstrip("/")
    workdir_name = co_spec.rstrip("/").split("/").pop()
    workdir_path = os.path.abspath(workdir_name)
    if args:
        workdir_path = tounicode(os.path.abspath(args.pop(0)))
    if os.path.exists(workdir_path):
        raise UserError("Workdir path '%s' already exists" % (workdir_path))
    assert not args # Args parsing complete

    repourl = get_repo_url()
    front = connect_to_repo(repourl)

    latest_sid = front.find_last_revision(session_name)
    if not latest_sid:
        raise UserError("No such session found: %s" % (session_name))

    if options.revision:
        if options.revision not in front.get_session_ids(session_name):
            raise UserError("There is no such revision of the given session")
        sid = options.revision
    else:
        sid = latest_sid

    print "Checking out to workdir", workdir_path

    os.mkdir(workdir_path)
    wd = workdir.Workdir(repourl, session_name, offset, sid, workdir_path)
    wd.checkout()

def cmd_setprop(args):
    parser = OptionParser(usage="usage: boar setprop [options] <session name> <property> [new value]")
    parser.add_option("-f", "--file", action="store", dest = "file", 
                      help="Read the new property value from the given file")
    (options, args) = parser.parse_args(args)
    if len(args) < 2:
        raise UserError("You must specify a session and a property name")
    if len(args) > 3:
        raise UserError("Too many arguments")
    if not options.file and len(args) != 3:
        raise UserError("Not enough arguments")
    if options.file and len(args) > 2:
        raise UserError("You can not specify both a source file and a new value")

    front = connect_to_repo(get_repo_url())

    if options.file:
        session_name, property_name = args
        try:        
            with safe_open(options.file, "r") as f:
                new_value = f.read().decode("utf-8")
        except Exception, e:
            raise UserError("Problems reading file %s: %s" % (options.file, e))
    else:
        session_name, property_name, new_value = args

    if property_name == "ignore":
        valid_lines = [line for line in new_value.splitlines() if line]
        front.set_session_ignore_list(session_name, valid_lines)
    elif property_name == "include":
        valid_lines = [line for line in new_value.splitlines() if line]
        front.set_session_include_list(session_name, valid_lines)
    else:
        raise UserError("Property name must be one of the following: ignore, include")

def cmd_getprop(args):
    parser = OptionParser(usage="usage: boar getprop [options] <session name> <property>")
    parser.add_option("-f", "--file", action="store", dest = "file", 
                      help="Write the property value to the given file instead of printing it")
    (options, args) = parser.parse_args(args)
    if len(args) < 2:
        raise UserError("You must specify a session and a property name")
    if len(args) > 2:
        raise UserError("Too many arguments")

    session_name, property_name = args
    front = connect_to_repo(get_repo_url())

    property_value = u""
    if property_name == "ignore":
        ignore_list = front.get_session_ignore_list(session_name)
        for item in ignore_list:
            property_value += item + os.linesep
    else:
        raise UserError("Property name must be one of the following: ignore")

    if options.file:
        try:        
            with open(options.file, "w") as f:
                f.write(property_value)
        except Exception, e:
            raise UserError("Problems writing file %s: %s" % (options.file, e))
    else:
        print property_value


def cmd_find(front, args):
    cs, sessionName = args
    sessionId = front.find_last_revision(sessionName)
    for bi in front.get_session_bloblist(sessionId):
        if bi['md5sum'] == cs:
            print bi['filename']

def cmd_lostfiles(args):
    restore_missing = "-u" in args
    wd = workdir.init_workdir(ucwd)
    if not wd:
        raise UserError(not_a_workdir_msg)    
    for bi in wd.get_bloblist(wd.revision):
        if not wd.exists_in_workdir(bi['md5sum']):
            print "Missing:", bi['filename'], bi['md5sum']
            if restore_missing:
                wd.fetch_file(bi['filename'], bi['md5sum'], overwrite = False)

def __clone_once(source_front, target_front):
    if front.is_identical(source_front, target_front):
        print "Repositories are already identical"
        return

    print "Quick verifying source repo"
    verify_repo(source_front, verify_blobs = False)
    print "Quick verifying destination repo"
    verify_repo(target_front, verify_blobs = False)
    front.clone(source_front, target_front)
    print "Performing full verify on cloned repo"
    verify_repo(target_front, verify_blobs = True)
    print "Repos are in sync."

def __clone_replicate(repo1, repo2):
    print "Entering continous replication mode."
    print "Will replicate all incoming changes on %s to %s" % (repo1, repo2)
    while True:
        if repo1.isIdentical(repo2):
            time.sleep(60)
            continue
        print "Incoming changes found. Cloning..."
        verify_repo(Front(repo1), verify_blobs = False)
        print "Quick verifying destination repo"
        verify_repo(Front(repo2), verify_blobs = False)
        repo2.pullFrom(repo1)
        print "Performing full verify on cloned repo"
        verify_repo(Front(repo2), verify_blobs = True)
        print "Repos are in sync. Waiting for incoming changes..."

def cmd_clone(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar clone <source repo> <destination repo>")
    parser.add_option("-r", "--replicate", dest = "replicate", action="store_true",
                      help="Continously replicate any changes from the master to the clone (does not return)")
    (options, args) = parser.parse_args(args)
    if len(args) != 2:
        raise UserError("You must specify one source repository and one destination repository.")
    repopath1, repopath2 = args
    source_front = client.connect(repopath1)
    if not client.is_boar_url(repopath2) and not os.path.exists(repopath2):
        repository.create_repository(repopath2)
    target_front = client.connect(repopath2)
    if not front.is_continuation(base_front = target_front, cont_front = source_front):
        raise UserError("The source repo is not a continuation of the destination repo. Cannot clone.")
    if options.replicate:
        __clone_replicate(source_front, target_front)
    else:
        __clone_once(source_front, target_front)


def cmd_diffrepo(args):
    if len(args) == 0:
        args = ["--help"]
    parser = OptionParser(usage="usage: boar diffrepo <repo 1> <repo 2>")
    (options, args) = parser.parse_args(args)
    if len(args) != 2:
        raise UserError("You must specify exactly two existing repositories.")
    repopath1, repopath2 = args
    if repopath1.startswith("boar://") or repopath2.startswith("boar://"):
        raise UserError("Cloning requires local repositories")
    repopath1 = os.path.abspath(repopath1)
    repopath2 = os.path.abspath(repopath2)
    repo1 = Front(client.user_friendly_open_local_repository(repopath1))
    repo2 = Front(client.user_friendly_open_local_repository(repopath2))
    if front.is_identical(repo1, repo2):
        assert front.is_identical(repo2, repo1)
        print "Repositories are identical"
        return_code = 0
    else:
        print "Repositories differ"
        return_code = 1
    return return_code

def cmd_export_md5(wd, args):
    wd.export_md5()

def get_repo_url_commandline():
    global cmdline_repo
    if cmdline_repo == None:
        return None
    url = cmdline_repo
    if not client.is_boar_url(url):
        url = os.path.abspath(url)
    assert isinstance(url, unicode)
    return url

def get_repo_url_env():
    url = tounicode(os.getenv("REPO_PATH"))
    if url == None:
        return None
    if not client.is_boar_url(url):
        return os.path.abspath(url)
    assert isinstance(url, unicode)
    return url

def get_repo_url():
    url = get_repo_url_commandline()
    if not url:
        url = get_repo_url_env()
    if not url:
        raise UserError("You need to specify a repository to operate on. "+\
                            "Use the --repo option or set $REPO_PATH.")
    return url

def connect_to_repo(repourl):
    return client.connect(repourl)

def json_bug_test():
    if type(json.loads(json.dumps("abc"))) != unicode:
        raise UserError("Your Python version seems to contain a known json decoding bug (http://bugs.python.org/issue10038). It affects Python 2.7 and 2.7.1. You should upgrade (or downgrade) your Python installation.")
    
def main():
    json_bug_test()

    args = sys.argv[1:]
    global cmdline_repo
    cmdline_repo = None

    # --EXEC is only intended for whitebox testing code that needs
    # invasive access. It should never be used in normal usage.
    if args and args[0] == "--EXEC":
        execfile(args[1])
        args = args[2:]

    if "--version" in args:
        if len(args) != 1:
            raise UserError("The --version option can not be combined with other options")
        print "Boar, version %s" % BOAR_VERSION
        print "Copyright (C) 2010-2012 Mats Ekberg."
        print "Licensed under the Apache License, Version 2.0"
        return 0

    for i in range(0, len(args)):
        # This is ridiculous, but I just can't get OptParse to just
        # look for --repo without exploding on other "unknown options".
        # TODO: make less silly
        if args[i] == "--repo":
            args.pop(i)
            try:
                cmdline_repo = args.pop(i) 
                break
            except:
                raise UserError("You must specify a valid repository after --repo")
        if args[i].startswith("--repo="):
            _, cmdline_repo = args.pop(i).split("=")
            break

    if len(args) == 0:
        print_help()
        return 1

    if args[0] == "mkrepo":
        return cmd_mkrepo(args[1:])
    elif args[0] == "import":
        return cmd_import(args[1:])
    elif args[0] == "list":
        return cmd_list(args[1:])
    elif args[0] == "log":
        return cmd_log(args[1:])
    elif args[0] == "ls":        
        return cmd_ls(args[1:])
    elif args[0] == "verify":
        return cmd_verify(args[1:])
    elif args[0] == "repair":
        return cmd_repair(args[1:])
    elif args[0] == "co":
        return cmd_co(args[1:])
    elif args[0] == "status":
        return cmd_status(args[1:])
    elif args[0] == "info":
        return cmd_info(args[1:])
    elif args[0] == "ci":
        return cmd_ci(args[1:])
    elif args[0] == "update":
        return cmd_update(args[1:])
    elif args[0] == "find":
        front = get_repo_url()
        return cmd_find(front, args[1:])
    elif args[0] == "locate":
        return cmd_locate(args[1:])
    elif args[0] == "lostfiles":
        return cmd_lostfiles(args[1:])
    elif args[0] == "mksession":
        return cmd_mksession(args[1:])
    elif args[0] == "mkstandalone":
        return cmd_mkstandalone(args[1:])
    elif args[0] == "truncate":
        return cmd_truncate(args[1:])
    elif args[0] == "exportmd5":
        wd = workdir.init_workdir(ucwd)
        return cmd_export_md5(wd, args[1:])
    elif args[0] == "clone":
        return cmd_clone(args[1:])
    elif args[0] == "diffrepo":
        return cmd_diffrepo(args[1:])
    elif args[0] == "setprop":
        return cmd_setprop(args[1:])
    elif args[0] == "getprop":
        return cmd_getprop(args[1:])
    else:
        print_help()
        return 1

return_code = 0

if __name__ == "__main__":
    t1 = time.time()
    sys.stdout = StreamEncoder(sys.stdout)
    sys.stderr = StreamEncoder(sys.stderr)
    sys.argv = map(tounicode, sys.argv)
    global ucwd
    ucwd = tounicode(os.getcwd())
    #cProfile.run('main()', "prof.txt")
    #import pstats
    #p = pstats.Stats('prof.txt')
    #p.sort_stats('cum').print_stats(10)
    #sys.exit(0)
    try:
        return_code = main()
    except KeyboardInterrupt:
        print
        print "ERROR: Operation cancelled by user"
        return_code = 1
    except UserError as e:
        #import traceback
        #print "-"*60
        #traceback.print_exc(file=sys.stdout)
        #print "-"*60
        print "ERROR:", e
        return_code = 1
    except repository.MisuseError as e:
        print "REPO USAGE ERROR:", e
        return_code = 1
    except repository.CorruptionError as e:
        print "REPO CORRUPTION:", e
        return_code = 13
    except repository.SoftCorruptionError as e:
        print "SOFT REPO CORRUPTION:", e
        print "No need to panic. This means that there are problems in some non-vital cache files in the repository."
        print "Execute a 'repair' command on the repository to fix this problem."
        return_code = 7
 
    t2 = time.time()
    print "Finished in", round(t2-t1, 2), "seconds"
    #import common
    #print "Processed", common._file_reader_sum, "bytes"
    sys.exit(return_code)
